/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 

def clientVersion() {
    return "03.02.00"
}

/**
 * Intruder Alert with Alarms, Lights and Camera Pictures
 *
 * Author: SmartThings, updates by RBoy Apps
 * Changes Copyright RBoy Apps, redistribution of any changes or modified code is not allowed without permission
 * 2018-2-7 - (v03.02.00) Added support for a panic switch,button to set off the alarm and resident contact sensors
 * 2018-1-9 - (v03.00.00) Added support for defining  upto 3 operating schedules
 * 2018-1-8 - (v02.04.00) Added support for disabling push notifications, added support for playing backing messages on audio devices
 * 2017-5-26 - (v02.03.00) Added support for automatic reseting of the app when no Alarm is used, disabled flashing lights, improved responsiveness
 * 2017-5-26 - (v02.02.00) Added notifications when all alarms are turned off when a single alarm is detected to be turned off, added support for multiple SMS number notifications by separating with a *
 * 2016-11-3 - Added support for tamper devices and for automatic code updates
 * 2016-10-22 - Empty/no delay time now sets it to immediate arming
 * 2016-8-31 - Fix for SMS not being sent, added support for arming notifications, improved system arming setup
 * 2016-8-17 - Added version and workaround for ST contact address book bug
 * 2016-2-22 - Include alarm source details when sending alarm notifications
 * 2016-1-17 - You can specify multiple sms phone numbers by putting a + to separate them
 * 2016-1-5 - Added support to set off alarm when a door is unlocked
 * 2015-11-27 - Added support to set dimmer levels to 100% while turning on the lights
 * 2015-2-15 - Bug fix for lights not coming on, change input to phone number for text message
 * 2015-2-2 - Added support for turning on lights/switches
 */
definition(
    name: "Intruder Alert with Alarms, Lights and Camera Pictures",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Alerts you when there are intruders and turns on lights/alarms but not when you just got up for a glass of water in the middle of the night",
    category: "Safety & Security",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/SafetyAndSecurity/App-IsItSafe.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/SafetyAndSecurity/App-IsItSafe@2x.png"
)

preferences {
    page(name: "mainPage")
    page(name: "scheduleCodesPage")
}

def mainPage() {
    dynamicPage(name: "mainPage", title: "Intruder Alert with Alarms, Lights and Camera Pictures v${clientVersion()}", install: true, uninstall: true) {
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            log.error "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
            sendPush "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
            section("INVALID HUB LOCATION") {
                paragraph title: "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately", required: true, ""
            }
        }

        section("Devices detecting an intruder") {
            input "intrusionMotions", "capability.motionSensor", title: "Motion Sensors", multiple: true, required: false
            input "intrusionContacts", "capability.contactSensor", title: "Contact Sensors", multiple: true, required: false
            input "intrusionLocks", "capability.lock", title: "Door Locks", multiple: true, required: false
            input "tamperDevices", "capability.tamperAlert", title: "Tamper Devices", multiple: true, required: false
        }
        section("Select panic devices to trigger alarms") {
            input "panicSwitches", "capability.switch", title: "Panic Switch", multiple: true, required: false
            input "panicButtons", "capability.button", title: "Panic Button", multiple: true, required: false
        }
        section("Sensors detecting residents") {
            input "residentMotions", "capability.motionSensor", title: "Motion Sensors", multiple: true, required: false
            input "residentContacts", "capability.contactSensor", title: "Contact Sensors", multiple: true, required: false
        }
        section("Alarm settings and actions") {
            input "alarms", "capability.alarm", title: "Which Alarm(s)", multiple: true, required: false, submitOnChange: true
            if (alarms) {
                input "seconds", "number", title: "Delay in seconds before siren sounds (optional)", required: false
                input "silent", "enum", options: ["Yes","No"], title: "Flash alarm lights only (if supported)", required: true
            }
            input "cameras", "capability.imageCapture", title: "Which Cameras(s) to take pictures", multiple: true, required: false
            input "lightson", "capability.switch", title: "Turn on these lights", multiple: true, required: false
            //input "lightsFlashing", "capability.switch", title: "Flash these lights", multiple: true, required: false // Flashing doesn't work reliably with the z-wave/zigbee mesh yet
        }
        section("Notifications") {
            input "textMessage", "text", title: "Send this message (optional)", multiple: false, required: false
            input("recipients", "contact", title: "Send notifications to", multiple: true, required: false) {
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*+448747654321"
                input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
                paragraph "Enable the below option if you DON'T want push notifications on your SmartThings phone app."
                input name: "disableAllNotify", title: "Disable all push notifications", type: "bool", defaultValue: "false", required: true
            }
            input name: "audioDevices", title: "Play notifications on these devices", type: "capability.audioNotification", required: false, multiple: true, image: "http://www.rboyapps.com/images/Horn.png"

            paragraph "Enable this option to get more detailed notifications like arming estimate"
            input "armNotifications", "bool", title: "Get detailed notifications", required: false
        }
        section("Arm system after residents are quiet") {
            input "residentsQuietThreshold", "number", title: "Delay arming time (minutes)", required: false
        }
        section("Operating Schedules") {
            // 3 schedule options
            ('A'..'C').each { schedule ->
                def hrefParams = [
                    user: 1 as String,
                    schedule: schedule,
                    passed: true
                ]
                href(name: "schedule${schedule}", params: hrefParams, title: "...click here to define schedule ${schedule}", page: "scheduleCodesPage", description: (settings."userDayOfWeek${schedule}${1}" ? "${settings."userDayOfWeek${schedule}${1}"}: ${settings."userStartTime${schedule}${1}" ? (new Date(timeToday(settings."userStartTime${schedule}${1}", timeZone).time)).format("HH:mm z", timeZone) : ""} - ${settings."userEndTime${schedule}${1}" ? (new Date(timeToday(settings."userEndTime${schedule}${1}", timeZone).time)).format("HH:mm z", timeZone) : ""}" : "Not defined"), required: false)
            }
        }
        section("Operating Modes") {
            mode title: "Enable system only when in this mode(s)", required: !anySchedule(), multiple: true // Mode is now optional when we have operating schedules
        }
        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
        }
    }
}

private anySchedule() {
    def defined = false
    ('A'..'C').each { schedule ->
        if (settings."userDayOfWeek${schedule}${1}" && settings."userStartTime${schedule}${1}" && settings."userEndTime${schedule}${1}") {
            defined = true
        }
    }
    
    return defined
}

def scheduleCodesPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    def schedule = ""
    // Get user from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.user) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user $user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    // Get schedule from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.schedule) {
        schedule = params.schedule ?: ""
        log.trace "Passed from main page, using params lookup for schedule $schedule"
    } else if (atomicState.params) {
        schedule = atomicState.params.schedule ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for schedule $schedule"
    } else {
        log.error "Invalid params, no schedule found. Params: $params, saved params: $atomicState.params"
    }

    log.trace "Schedule Codes Page, schedule:$schedule, user:$user, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"scheduleCodesPage", title: "Define schedule ${schedule}", uninstall: false, install: false) {
        section() {
            def i = user as Integer
            def priorUserDayOfWeek = settings."userDayOfWeek${schedule}${i}"
            def priorUserStartTime = settings."userStartTime${schedule}${i}"
            def priorUserEndTime = settings."userEndTime${schedule}${i}"
            log.debug "Schedule:$schedule, User:$i, UserDayOfWeek: $priorUserDayOfWeek, UserStartTime: $priorUserStartTime, UserEndTime: $priorUserEndTime"

            input "userStartTime${schedule}${i}", "time", title: "Start Time", required: false
            input "userEndTime${schedule}${i}", "time", title: "End Time", required: false
            input "userDayOfWeek${schedule}${i}",
                "enum",
                title: "Which day of the week?",
                required: false,
                multiple: true,
                options: [
                    'All Week',
                    'Monday to Friday',
                    'Saturday & Sunday',
                    'Monday',
                    'Tuesday',
                    'Wednesday',
                    'Thursday',
                    'Friday',
                    'Saturday',
                    'Sunday'
                ]
        }
    }
}

def installed() {
	log.debug "INSTALLED with $settings"
	subscribeToEvents()
}

def updated() {
	log.debug "UPDATED with $settings"
	subscribeToEvents()
}

private subscribeToEvents()
{
	unschedule()
	unsubscribe()
	alarms?.off() // Reset any alarms

    state.alarmActive = false
	state.residentsAreUp = false
    state.armNotification = false
	state.lastArmRequest = null

    subscribe(intrusionMotions, "motion", intruderMotion)
	subscribe(intrusionContacts, "contact", contact)
	subscribe(intrusionLocks, "lock", door)
	subscribe(alarms, "alarm", alarm)
    subscribe(tamperDevices, "tamper", tamper)
    subscribe(panicSwitches, "switch", panic)
    subscribe(panicButtons, "button", panic)
    subscribe(location, "mode", modeChangeHandler)
	subscribe(app, appTouch)

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm
}

def modeChangeHandler(evt) {
    log.trace "Mode change notification, ${evt ? "name: ${evt.name}, value: ${evt.value}" : "delayed checking"}"
    scheduleReArmCheck()
}

def appTouch(evt) {
    log.info "Resetting alarms and rearming system"
	subscribeToEvents()
}

def panic(evt) {
    if ((evt.value == "on") || (evt.value == "held") || (evt.value == "pushed")) {
        log.trace "Panic switch/button $evt.displayName activated, starting intruder alarm sequence"
        startAlarmSequence(evt)
    }    
}

def tamper(evt) {
    if (evt.value == "detected") {
		log.trace "Tamper $evt.displayName by potential intruder, residentsAreUp: $state.residentsAreUp"
		if (!state.residentsAreUp) {
			if (residentsHaveBeenQuiet()) {
				startAlarmSequence(evt)
			} else {
				disarmIntrusionDetection()
			}
        } else {
            log.trace "Residents are up, ignoring"
        }
	}    
}

def intruderMotion(evt) {
	if (evt.value == "active") {
		log.trace "$evt.displayName motion by potential intruder, residentsAreUp: $state.residentsAreUp"
		if (!state.residentsAreUp) {
			if (residentsHaveBeenQuiet()) {
				startAlarmSequence(evt)
			} else {
				disarmIntrusionDetection()
			}
        } else {
            log.trace "Residents are up, ignoring"
        }
	}
}

def contact(evt) {
	if (evt.value == "open") {
		log.trace "Contact $evt.displayName opened by potential intruder, residentsAreUp: $state.residentsAreUp"
		if (!state.residentsAreUp) {
			if (residentsHaveBeenQuiet()) {
				startAlarmSequence(evt)
			} else {
				disarmIntrusionDetection()
			}
        } else {
            log.trace "Residents are up, ignoring"
        }
	}
}

def door(evt) {
    if (evt.value == "unlocked") {
		log.trace "Door $evt.displayName unlocked by potential intruder, residentsAreUp: $state.residentsAreUp"
        if (!state.residentsAreUp) {
            if (residentsHaveBeenQuiet()) {
                startAlarmSequence(evt)
            } else {
                disarmIntrusionDetection()
            }
        } else {
            log.trace "Residents are up, ignoring"
        }
    }
}

def alarm(evt)
{
	log.trace "Alarm $evt.name: $evt.value"
	if (evt.value == "off") { // If any one alarm is turned off, turn off the rest
		alarms?.off()
		state.alarmActive = false

        def msg = "$evt.displayName: Alarm turned off, turning off all other alarms"
        log.debug msg
        if (armNotifications) {
            sendNotifications(msg) // Do this in the end as it may timeout
        }
    }
}

private residentsHaveBeenQuiet() {
	def threshold = (residentsQuietThreshold ?: 0) * 60 * 1000
	def result = true
	def t0 = new Date(now() - threshold)
	
    for (sensor in residentMotions) {
		def recentStates = sensor.statesSince("motion", t0)
		if (recentStates.find{it.value == "active"}) {
			result = false
			break
		}
	}
	
    for (sensor in residentContacts) {
		def recentStates = sensor.statesSince("motion", t0)
		if (recentStates.find{it.value == "open"}) {
			result = false
			break
		}
	}
    
	log.trace "residentsHaveBeenQuiet: $result"
	result
}

private disarmIntrusionDetection() {
	log.trace "Disarming intrusion detection"
	state.residentsAreUp = true
	scheduleReArmCheck()
}

private scheduleReArmCheck() {
    state.armNotification = false // Reset each time we start a rearm
	state.lastArmRequest = now()
	def cron = "0 0/1 * * * ?" // Check every 1 minute
	schedule(cron, "checkForReArm")
	log.trace "Starting re-arm check, cron: $cron"
    checkForReArm()
}

def checkForReArm() {
    // Check if we are within any of the operating schedules
    def activeSchedule = false
    ('A'..'C').each { schedule ->
        if (settings."userStartTime${schedule}${1}" && settings."userEndTime${schedule}${1}") {
            if (checkSchedule(1, schedule)) { // Within operating schedule
                activeSchedule = true
            }
        } else {
            log.warn "Invalid schedule settings for schedule $schedule, no start or end time defined"
        }
    }
    
    if (anySchedule() && !activeSchedule) { // If we have a schedule defined and we are outside the operating schedule
        log.debug "Outside operating schedule, not arming system"
        return
    }

	def threshold = (residentsQuietThreshold ?: 0) * 60 * 1000
	// check last intruder motion
	def lastIntruderMotion = state.lastArmRequest
	log.trace "checkForReArm: lastArmRequest=${lastIntruderMotion/1000} seconds"
	if (lastIntruderMotion != null)
	{
		log.debug "checkForReArm, time since last arm request: ${(now() - lastIntruderMotion)/(1000)} seconds, threshold is ${threshold/1000} seconds"
		if (now() - lastIntruderMotion > threshold) {
            def msg = "Arming Intruder Alert System"
            if (armNotifications) {
                msg += " for ${location.mode} mode"
            }
			state.residentsAreUp = false
            state.armNotification = false
			unschedule(checkForReArm)
			log.debug msg
            if (armNotifications) {
                sendNotifications(msg) // Do this in the end as it may timeout
            }
		} else {
            if (!state.armNotification) {
                state.armNotification = true // We've sent a notification
                def timeToArm = ((now() - lastIntruderMotion + threshold)/(60*1000)) as Float
                log.trace "Time to arm: $timeToArm minutes"
                if (timeToArm < 1) { // If we have less than a minute then show it as 1 minute since the scheduler it setup for 1 minute checks
                    timeToArm = 1
                }
                def msg = "Arming Intruder Alert System in about ${timeToArm.round()} minutes"
                log.debug msg
                if (armNotifications) {
                    sendNotifications(msg) // Do this in the end as it can timeout
                }
            }
        }
	} else {
		log.warn "checkForReArm: lastIntruderMotion was null, unable to check for re-arming intrusion detection"
	}	
}

private startAlarmSequence(evt) {
    // Check if we are within any of the operating schedules
    def activeSchedule = false
    ('A'..'C').each { schedule ->
        if (settings."userStartTime${schedule}${1}" && settings."userEndTime${schedule}${1}") {
            if (checkSchedule(1, schedule)) { // Within operating schedule
                activeSchedule = true
            }
        } else {
            log.warn "Invalid schedule settings for schedule $schedule, no start or end time defined"
        }
    }
    
    if (anySchedule() && !activeSchedule) { // If we have a schedule defined and we are outside the operating schedule
        disarmIntrusionDetection()
        log.info "Outside operating schedule, ignoring event and disarming system"
        return
    }

	if (state.alarmActive) {
		log.trace "Alarm already active"
	} else {
		log.trace "Starting intruder actions sequence"

        // Only set this if we have Alarms defined because it will be reset when the alarms are turned off, without alarms start sequence every time
        if (alarms) {
            state.alarmActive = true
            if (silent == "Yes") {
                log.debug "Silent alarm only"
                alarms?.strobe()
            } else {
                def delayTime = seconds
                if (delayTime) {
                    alarms?.strobe()
                    runIn(delayTime, "soundSiren")
                    log.trace "Sounding siren in $delayTime seconds"
                } else {
                    soundSiren()
                }
            }
        }

		if (lightsFlashing) {
			log.debug "Flashing lights"
			runIn(1, "continueFlashing") // do it offline to avoid timeout since it's a heavy activity
		}
        
        if (lightson) {
        	log.debug "Turning on lights $lightson"
        	lightson?.on()
            lightson?.each { lighton -> 
                if (lighton?.hasCommand("setLevel")) {
                    lighton?.setLevel(100) // If it is a dimmer set it to 100%
                }
            }
        }

        if (cameras) {
        	log.debug "Taking pictures with $cameras"
        	cameras?.take()
        }

        // Do this in the end because it can timeout
        sendNotifications(textMessage ? "$evt.displayName: $textMessage" : "$evt.displayName: Potential intruder detected")
    }
}

def soundSiren() {
	if (state.alarmActive) {
		log.debug "Sounding siren"
		alarms?.both()
	} else {
		log.debug "Intruder notification reset, alarm activation aborted"
	}
}

def continueFlashing() {
    // Flash 10 times
    state.flashingCount = (state.flashingCount ?: 0) + 1
    if (state.flashingCount <= 10) {
        flashLights(1000)
        runIn(2, "continueFlashing") // After 2 seconds because we're turning off after 1 second
        log.trace "Flashing lights counter: $state.flashingCount"
    } else {
        state.flashingCount = 0 // Reset it
        log.trace "Finished flashing"
    }
}

private flashLights(long delay) {
    lightsFlashing?.on()
    lightsFlashing?.off([delay: delay])
}

// Checks if we are within the current operating scheduled
// Inputs to the function are user (i) and schedule (x) (there can be multiple schedules)
// Preferences required in user input settings are:
// settings."userStartTime${x}${i}"
// settings."userEndTime${x}${i}"
// settings."userDayOfWeek${x}${i}"
private checkSchedule(def i, def x) {
    log.debug "Checking operating schedule $x for user $i"

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendPush "Hub location/timezone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
    }

    def doChange = false
    Calendar localCalendar = Calendar.getInstance(timeZone)
    int currentDayOfWeek = localCalendar.get(Calendar.DAY_OF_WEEK)
    def currentDT = new Date(now())

    // some debugging in order to make sure things are working correclty
    log.debug "Current time: ${currentDT.format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Check if we are within operating times
    if (settings."userStartTime${x}${i}" != null && settings."userEndTime${x}${i}" != null) {
        def scheduledStart = timeToday(settings."userStartTime${x}${i}", timeZone)
        def scheduledEnd = timeToday(settings."userEndTime${x}${i}", timeZone)

        if (scheduledEnd <= scheduledStart) { // End time is next day
            def localHour = currentDT.getHours() + (int)(timeZone.getOffset(currentDT.getTime()) / 1000 / 60 / 60)
            //log.trace "Local hour is $localHour"
            if (( localHour >= 0) && (localHour < 12)) // If we between midnight and midday
            {
                log.debug "End time is before start time and we are past midnight, assuming start time is previous day"
                scheduledStart = scheduledStart.previous() // Get the start time for yesterday
            } else {
                log.debug "End time is before start time and we are past midday, assuming end time is the next day"
                scheduledEnd = scheduledEnd.next() // Get the end time for tomorrow
            }
        }

        log.debug("Operating Start ${scheduledStart.format("HH:mm z", timeZone)}, End ${scheduledEnd.format("HH:mm z", timeZone)}")

        if (currentDT < scheduledStart || currentDT > scheduledEnd) {
            log.debug("Outside operating time schedule")
            return false
        }
    }

    // Check the condition under which we want this to run now
    // This set allows the most flexibility.
    log.debug("Operating DOW(s): ${settings."userDayOfWeek${x}${i}"}")

    if(settings."userDayOfWeek${x}${i}" == null) {
        log.warn "Day of week not specified for operating schedule $x for user $i, assuming no schedule set, so we are within schedule"
        return true
    } else if(settings."userDayOfWeek${x}${i}".contains('All Week')) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Monday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.MONDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Tuesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.TUESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Wednesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.WEDNESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Thursday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.THURSDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Friday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.FRIDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Saturday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SATURDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Sunday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SUNDAY) {
        doChange = true
    }


    // If we have hit the condition to schedule this then lets do it
    if(doChange == true){
        log.debug("Within operating schedule")
        return true
    }
    else {
        log.debug("Outside operating schedule")
        return false
    }
}

private void sendText(number, message) {
    if (number) {
        def phones = number.split("\\*")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

private void sendNotifications(message) {
	if (!message) {
		return
    }
    
    if (location.contactBookEnabled) {
        sendNotificationToContacts(message, recipients)
    } else {
        if (!disableAllNotify) {
            sendPush message
        } else {
            sendNotificationEvent(message)
        }
        if (sms) {
            sendText(sms, message)
        }
    }
    if (audioDevices) {
        audioDevices*.playText(message)
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Intruder Alert with Alarms, Lights and Camera Pictures"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = 
                [ intrusionMotions,
                 intrusionContacts,
                 intrusionLocks,
                 tamperDevices,
                 panicSwitches,
                 panicButtons,
                 residentMotions,
                 residentContacts,
                 alarms,
                 cameras,
                 lightson,
                 lightsFlashing ]
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (!disableUpdateNotifications) {
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}